# Адеев Владислав Николаевич АИС-23-1
# Тема 8. Введение в ООП
Отчет по Теме #8 выполнил(а):

- Адеев Владислав Николаевич
- АИС-23-1


| Задание  | Лаб_раб | Сам_раб |
| ------------- | ------------- | --- |
| 1 | + | + |
| 2 | + | + |
| 3 | + | + |
| 4 | + | + |
| 5 | + | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

## Лабораторная работа №1
### Создайте класс “Car” с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями.
``` Python
class Car: #Объявление класса
    def __init__(self, make, model): #Конструктор, self - ссылка для обращения к самому объекту, make и model - параметры
        self.make = make #Присвоение значений параметрам
        self.model = model

my_car = Car("Ford", "Mustang") #Изменение значений полей
```

## Лабораторная работа №2
### Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину “поехать”. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
``` Python
class Car: #Объявление класса
    def __init__(self, make, model): #Конструктор, self - ссылка для обращения к самому объекту, make и model - параметры
        self.make = make #Присвоение значений параметрам
        self.model = model

    def drive(self):#Объявление метода
        print(f"Driving the {self.make} {self.model}")#Тело метода

my_car = Car("Ford", "Mustang") #Изменение значений полей
my_car.drive() #Вызываем метод drive и заставляем машину "ехать"
```
### Результат
<img width="1714" height="269" alt="image" src="https://github.com/user-attachments/assets/08f09042-e89f-4c8c-b4c5-a5ef8cd5c8eb" />


## Лабораторная работа №3
### Создайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
``` Python
class Car: #Объявление класса
    def __init__(self, make, model): #Конструктор, self - ссылка для обращения к самому объекту, make и model - параметры
        self.make = make #Присвоение значений параметрам
        self.model = model

    def drive(self):#Объявление метода
        print(f"Driving the {self.make} {self.model}")#Тело метода

my_car = Car("Ford", "Mustang") #Изменение значений полей
my_car.drive() #Вызываем метод drive и заставляем машину "ехать"

class ElectroCar(Car): #Объявление класса с наследованием класса Car
    def __init__(self, make, model, battery_capacity): #Конструктор
        super().__init__(make, model) #super позволяет вызывать методы родительского класса
        self.battery_capacity = battery_capacity

    def Charge(self):
        print(f"Charging the {self.make} {self.model} with battery capacity {self.battery_capacity} kWh")

MyElectricCar = ElectroCar("Tesla", "Model S", 75)
MyElectricCar.drive()
MyElectricCar.Charge()
```
### Результат
<img width="1711" height="266" alt="image" src="https://github.com/user-attachments/assets/06e90cb7-1920-4703-a00f-5fff63c3e22a" />

## Лабораторная работа №4
### Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
``` Python
class myCar:
    def __init__(self, make, model):
        self._make = make #Защищенный атрибут
        self.__model = model #Приватный атрибут

    def drive(self):
        print(f"Driving car {self._make} {self.__model}")

my_car = myCar("Ford", "Mustang")
print(my_car._make) #Доступ к защищенному классу
#print(my_car.__model) #Ошибка! Приватный атрибут не доступен
my_car.drive()
```
### Результат
<img width="1713" height="275" alt="image" src="https://github.com/user-attachments/assets/20b48f19-ee1d-443c-8fca-6403bbdb83f2" />

## Лабораторная работа №5
### Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль
``` Python
class Snape:
    def area(self): #Пустой метод для переопрпеделения в дочерних классах
        pass

class Rectangle(Snape): #Дочерний класс, наследует класс Snape
    def __init__(self, width, height): #Конструктор
        self.width = width
        self.height = height
    def area(self): #Функция, вычисляющая площадь треугольника
        return self.width * self.height

class Circle(Snape): #Дочерний класс, наследует класс Snape
    def __init__(self, radius): #Конструктор
        self.radius = radius

    def area(self): #Функция, вычисляющая площадь круга
        return 3.14*self.radius*self.radius

figures = [Rectangle(4, 5), Circle(3)] #Массив с фигурами
for figure in figures: #Цикл для вывода площадей
    print(figure.area())
```
### Результат
<img width="1708" height="276" alt="image" src="https://github.com/user-attachments/assets/cfa2db56-88d5-4c04-90de-b494fb5fa92d" />

## Самостоятельная работа №1
### 
``` Python

```
### Результат

### Вывод

## Самостоятельная работа №2
### 
``` Python

```
### Результат

### Вывод

## Самостоятельная работа №3
### 
``` Python

```
### Результат

### Вывод

## Самостоятельная работа №4
### 
``` Python

```
### Результат

### Вывод

## Самостоятельная работа №5
### 
``` Python

```
### Результат

### Вывод
